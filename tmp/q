让我重新解释这两个算法，重点说明其实现细节和原理：

算法 1 实现了两个基础函数。fixed_power_int 函数实现了定点数的快速幂运算，其核心思想是利用指数的二进制表示来优化计算过程。例如，要计算 x^11，由于 11 的二进制表示为 1011，因此 x^11 可以分解为 x^8 * x^2 * x^1。函数使用定点数算术，将 1.0 表示为 2^10 (1024)，这样可以在整数运算中保留小数精度。在每次乘法运算后，通过加入 2^9 (512) 并右移 10 位来实现四舍五入，这个操作相当于将结果除以 1024 并四舍五入。例如，当计算 1.5 * 1.5 时，在定点数表示中为 (1536 * 1536 + 512) >> 10，确保了精确的小数计算。

calc_load_n 函数实现了带有指数衰减的负载计算。它首先调用 fixed_power_int 计算衰减因子 α^periods，其中 α 是基础衰减因子（对于 10 秒窗口，α = e^(-2s/10s) 的定点数表示约为 1677）。计算得到的 factor 表示经过 periods 个周期后的衰减程度。函数随后将这个衰减因子应用于当前负载 load，并与新的贡献值 new_contrib 按比例混合。混合比例由 factor 决定：load 部分权重为 factor，new_contrib 部分权重为 (2^10 - factor)。最终结果再次通过除以 2^10 进行归一化。

算法 2 实现了完整的压力计算过程。首先是压力数据的收集和聚合：对每个 CPU，计算其压力时间增量 δPi 和非空闲时间增量 δNi。使用非空闲时间作为权重来累加压力值，这确保了即使 CPU 负载不均衡，最终的压力计算仍然准确。归一化压力通过将加权和除以总非空闲时间获得，这个值反映了系统整体的压力水平。

时间管理部分处理了采样周期和时钟漂移。当前时间 tnow 与预期更新时间 expires 的差值用于检测错过的采样周期。如果发现错过周期（missed > 0），算法会相应调整下次采样时间和实际周期长度。这种机制确保了即使在系统负载较重导致采样延迟的情况下，压力计算仍然能够准确反映系统状态。

压力样本的处理体现了算法的另一个关键创新。当计算得到的样本超过周期长度时，超出部分不会被丢弃，而是通过 total_prev 的更新机制自动转移到下个周期。这种设计确保了不会漏报压力事件，同时避免了报告超过 100% 的非实际压力值。

最后的平均值计算整合了所有这些机制。首先处理错过的周期，通过 calc_load_n 对历史平均值进行衰减。然后将新的压力样本转换为百分比并应用定点数转换，最终通过带衰减因子的加权平均得到更新后的平均值。这种计算方式既保持了对新压力事件的敏感性，又能够平滑地反映系统的压力变化趋势。

通过这种精心设计的计算流程，算法实现了准确、高效的压力计算，同时优雅地处理了定点数精度、时钟漂移、压力溢出等各种边缘情况。