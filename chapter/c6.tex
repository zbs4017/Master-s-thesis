\chapter{实验测试与结果分析}

\section{实验环境与测试负载}
\subsection{硬件配置}

使用性能较低的笔记本电脑作为实验平台，具体配置如下：
\begin{itemize}
    \item Intel(R) Core(TM) i7-8750H CPU @ 2.20GHz
    \item Memory: 16GB (2 × 8GB) DDR4 @ 2667MT/s SODIMM
    \item SSD: Intel SSDPEKKW256G8 NVMe SSD (256GB, PCIe Gen3 x4) 
    \item HDD:Seagate ST1000LM035 HDD (1TB, 5400 RPM)
\end{itemize}


由于硬件限制，实验配置了三种卸载后端，分别是机械磁盘，SSD和zram。主要是由于内核中没有实现官方的rdma 和 nvm的卸载后端。

为了能够体现出算法的自适应性，我们决定将zram作为性能最好的卸载后端，所以在测试中，我们使用压缩比非常高的数据来体现

\subsection{测试负载}

我们将使用一个web server 这种文件密集型和redis这种内存密集型负载来测试我们算法的有效性。

web server 包含主动限流功能，当发生延迟的时候，web server 会主动限流，保证延迟的稳定性，这样的话我们可以用每秒的请求数来衡量web server 这种吞吐量来衡量性能。

redis，我们禁止了所有持久化功能，并且关闭了淘汰策略的，因为这些功能策略会有复杂的用户态内存管理，他直接在用户态管理内存，导致我们很难模拟出内存压力。

没有使用数据库这种IO密集型负载，是因为数据库中一半有复杂的用户态内存管理，他们直接在用户态管理内存，并不能体现出我们算法的有效性。

\section{模块功能与有效性测试}

\subsection{内存压力模块有效性验证}
本节中我们将进行内存压力模块有效性验证，验证我们内存压力模块是否能够正确地模拟内存压力。


\subsubsection{测试方法与指标}

在测试中，使用两种应用，然后在内核中配置不同的卸载后端，然后通过mpfs查看内核是否量化了内存压力。

对于web server ，它包含大量的高清图片和文字，有很高的压缩比。压力发生器会保证在100ms内，web server 的内存压力达到100\%。

对于redis，我们也是保存一些图片和文字，有很高的压缩比。压力发生器会保证在100ms内，redis的内存压力达到100\%。

    \subsubsection{测试结果与分析}


    1. cpu占用要进行测试
    2. 还有就是性能，web server 的吞吐量，redis的qps
    3. 三种不同的卸载后端


    有不同的内存压力，

    cpu的话，机械内存占用是最高的，其次是zram，最后是ssd。由于zram由于需要压缩数据，所以cpu占用高。

    然后就是内存压力了。

    可以看到，两种应用，对应不同的卸载后端，内核都能够正确地量化内存压力。

    zram性能最好，有最高的压缩比，并且不需要和硬件进行交互，所以他的内存压力是最小的。

    SSD 性能其次，

    HDD 性能最差，频繁的换入换出，导致整个系统基本hang死，无法正常工作。


\subsection{自适应工作集估计算法有效性验证}
    \subsubsection{对比算法与评估指标}
    \subsubsection{测试结果与分析}

\subsection{文件页与匿名页均衡算法有效性验证}

    我们使用同样的测试场景，分别是给予了完全满足、部分满足、不满足三种内存配置方案。
    同时，我们改动swappiness 从 0 50 100 ，测试了不同的swappiness 对系统性能的影响。
    然后我们ebpf程序来hook函数，查看内核的refault次数。
    \subsubsection{测试场景}
    \subsubsection{测试指标}
    \subsubsection{测试结果与分析}

    对于web server ，由于是文件密集型，
    
    如果完全满足，性能一直是稳定的。
    如果部分满足， 对于swappiness 为0的时候，倾向于回收文件页，所以看到最开始的时候，refault次数很高，所以性能比较差。由于内核的调度，内核开始倾向于回收匿名页，所以 refault次数逐渐降低，性能逐步提升，
    随着swappiness 的增加，开始的时候refault开始减少，最终都趋于稳定，说明平衡了文件页和匿名页的回收。
    如果完全不满足，refault次数很高，swappiness的调节没有效果，因为我们在设计的时候就是假设内核中的内存足够存放下整个工作集的时候。

    对于redis，由于是内存密集型，
    完全满足内存，很少的refault次数。
    如果部分满足，对于swappiness 为0的时候，倾向于回收文件页，但是匿名页回收的少，所以内存不够，性能并没有很好。
    在50的时候，文件页面和匿名页面都会回收，这个时候反而性能好了，我们的程序并没有做。


    对于web server ，由于是文件密集型，
    完全满足内存，很少的refault次数。
    如果部分满足，对于swappiness 为0的时候，倾向于回收文件页，refault不多，性能页比较稳定。
    在50的时候，文件页 和匿名页都会回收，refault次数开始增加，

\section{综合测试}
\subsection{测试目标}
\subsection{测试场景与负载}
\subsection{测试结果与分析}

\section{本章小结}
